Your task is to build a Sports Betting Simulator using Java and Spring Boot. The provided materials include a starter project with a frontend, an API specification, and seed data.

GitHub Repository Requirements

Each team must create their own GitHub repository for the hackathon project.

1. Create a new GitHub repository under any team member’s GitHub account.  
2. Add all team members as collaborators with appropriate access rights.  
3. Add the designated hackathon reviewers as collaborators so they can access the repository for evaluation.  
4. Ensure the repository remains accessible until the evaluation process is fully completed.

Starter Kit Contents

- API Specification (openapi.yaml): Defines the backend service endpoints you must implement. Do not change these endpoints as they are designed to work with the provided frontend.  
- Sport Matches Seed File: A file to be read on service startup to generate initial matches.  
- Frontend code: No modifications to the frontend code are required.  
  How to run:  
  cd frontend && npm install && npm run dev (dev server proxies API to http://localhost:8080)

1. Match Lifecycle & Scheduling

- Match Seeding: Matches are loaded from a JSON seed file at startup. The file defines offsets in seconds (start time relative to service startup) and duration (end time) in seconds.  
- Every service startup must begin with the database in a fresh, empty state.  
- Betting Window: Bets can only be placed before a match starts.  
- Settlement: Implement a scheduler to randomly settle finished matches.  
  - Once a match finishes, the scheduler should publish a MatchFinished Kafka event.  
  - Listen for this event to settle placed bets and pay out winnings.

2. Technical Objectives & Requirements

Category | Requirements  
Project Setup | Use start.spring.io  
Development Practices | Use version control (GitHub).  
System Visibility | Implement robust logging for every request and system action. It must be possible to track all system actions through the logs.  
Core Functionality | Utilize: REST Endpoints, Scheduling, Cache, Kafka, Error Handling, Validation, and Tests.  
Infrastructure | Use Docker for running your chosen Database and Kafka. Include dockerfile in your repo.

3. Implementation Tasks

1. Match Management  
   1. Load Matches: Read the seed file and save the upcoming matches to your database.  
   2. List Upcoming Matches Endpoint:  
      - Implement an endpoint to list all upcoming and in‑progress matches (do not list finished matches).  
      - Implement caching (valid for 30 seconds).  
      - Evict the cache immediately when a match finishes.  
   3. List Finished Matches Endpoint:  
      - Implement an endpoint to list all finished matches.

2. Player Management  

- Note: No real authentication is required for the hackathon.  

1. Create Player: Implement an endpoint to create a player. Players must have a unique name and an initial account balance.  
2. Fetch Player: Implement an endpoint to retrieve a player’s details, including their current balance.  
   - Switching players is done by entering a player’s name (should be case‑insensitive).

3. Placing Bets  

1. Single Bet: Implement an endpoint to place a bet on a single outcome. The player must have sufficient balance.  
2. Combination Bet: Implement an endpoint to place a bet on multiple outcomes.  
   - The final odds are calculated by multiplying the odds of all selections.  
   - All selected outcomes must be correct to win the bet.  
   - The player must have sufficient balance.

4. History

1. Player’s Bet History: Implement an endpoint to fetch a player’s bets. The data should include: placement timestamp, status, settlement timestamp (if settled), stake amount, win amount, IDs (bet/match), odds, and the chosen outcome (Home/Draw/Away).  
   - Support filtering by status (e.g., Placed, Won, Lost).  
2. Player’s Transaction History: Implement an endpoint to fetch all credit and debit transactions for a player.

5. Bet Settlement

1. Match Result Generation: Schedule a job every 10 seconds to check for due matches. For any due match, publish a MatchFinished Kafka event with a randomly generated result.  
2. Event Processing & Payout:  
   - Listen for MatchFinished events and settle all associated bets.  
   - Ensure Idempotency: A winning player must receive their payout only once, even if the same event is received multiple times.  
   - Ensure Resilience: Implement good exception handling. If processing fails (e.g., payout error), the event must be reprocessed until successful without blocking new events.

Stretch goals: Bonus

1. Ensure payouts aren’t lost on crash. Introduce an outbox table for MatchFinished and a background dispatcher that retries failed publishes (idempotent with unique event IDs). Think about transactionability.  
2. Implement dynamic, stake‑driven odds that target a ~10% house margin, but only once a match has at least one bet placed on two different outcomes. Before that condition is met, keep using the initial static odds.  
   - Clamp odds to reasonable bounds (min 1.1, max 15.0) to avoid extremes.  
   - Add small smoothing (5).  
   - Bets lock the odds at placement time, later moves only affect future bets.  
   - Ensure cache/odds refresh is consistent.  
   - Add logging for visibility.

What is smoothing?  
It’s a small “fake stake” added to each outcome to keep probabilities stable when real money is very low or one‑sided. Think of it as a soft prior so odds don’t swing wildly on the first tiny bet and you never divide by zero.

What is a house margin?  
A house margin is the built‑in edge the bookmaker keeps by pricing outcomes so their implied probabilities sum to more than 100%. For example, if the implied probabilities add up to 110%, the extra 10% is the house margin: on average, across many events and balanced action, the book retains ~10% of the turnover.
@